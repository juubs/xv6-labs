LAB 4 DOCUMENTATION

Implmented the select system call defined in sysfile.c. Along with that are helper functions for file status defined in console.c, pipe.c, file.c, and fs.c, and a testing user programs in selecttest.c and pipenet.c.

My select system call *almost* works 100% as intended. It will pass all of the basic tests in selecttest (except for one exception, only sometimes). Unfortunately, the one bug I can't track down is this: sometimes to wake up a pipe/console FD to read or write requires an ENTER keypress. I've tried adjusting the readable/writeable conditions to see if it was waiting for a keypress when it should've woken up on an empty buffer. I've tried adjusting the select call itself but as far as I can tell I've written it to work. This is noticeable in "selecttest" when it sleeps on test1 - I have a helping print statement that states when all FDs are blocking and it is sleeping until one is available. If it pauses, at that message, pressing ENTER will wake it up and continue the test. Sometimes this doesn't happen because that test does not always have blocking FDs. This is most noticeable with the pipenet implementation. Pipenet works as it should - it won't lock up after the first read and write to and from the shell. However, each buffer output to the console requires an ENTER keypress to continue. Other than that, the select implementation for Pipenet solves the issue presented where the program blocks indefinitely.

Small note for selecttest: The success message for test3p is the "test3p passed!". That is the array of chars initialized in the write buffer in the test that gets read by a pipe with "read(fds[0],rbuf,32)" and written to the console with "write(1,rbuf,32)":. If that message is printed by selecttest, then the message was passed through the pipe and to the console properly.

=========

LAB 4 QUESTIONS

1. Select overwrites the input fd_set. Poll doesn't destroy this input data allowing the same one to be reused. Poll can handle many file handles without workarounds which select struggles with since it uses bitmasks for FD info. Select has to loop over the bitmask on return just to determine which type of event occured (read/write/error) while poll will set the data structure of the FD sets with the kind of event that occured.

2. I don't think this is possible with select. With poll, however, you could keep track of the latest write and then check where it wrote to to verify that it reads it correctly. Given some timeout before resetting the connection this could be implemented with poll. 

3. This should work. You could have pipenet loop over each read/write that it would want to wait for until one of the returns a success to move on. The drawback to this is the constant CPU usage - the entire time this is happening, the process is constantly jumping back and forth through read and writes until one of them works. With select, the process goes to sleep until one of the FDs will not block, leaving the CPU free to work on other processes while the select is blocking.

========

xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern x86-based multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
provides pointers to on-line resources for v6.

xv6 borrows code from the following sources:
    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
    FreeBSD (ioapic.c)
    NetBSD (console.c)

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by Silas
Boyd-Wickizer, Mike CAT, Nelson Elhage, Nathaniel Filardo, Peter Froehlich,
Yakir Goaran, Shivam Handa, Bryan Henry, Jim Huang, Anders Kaseorg, kehao95,
Eddie Kohler, Imbar Marinescu, Yandong Mao, Hitoshi Mitake, Carmi Merimovich,
Joel Nider, Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Cam Tenny,
Rafael Ubal, Warren Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi
Watanabe, Nicolas Wolovick, Jindong Zhang, and Zou Chang Wei.

The code in the files that constitute xv6 is
Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

If you spot errors or have suggestions for improvement, please send
email to Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu).

BUILDING AND RUNNING XV6

To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run "make".
On non-x86 or non-ELF machines (like OS X, even on x86), you will
need to install a cross-compiler gcc suite capable of producing x86 ELF
binaries.  See http://pdos.csail.mit.edu/6.828/2016/tools.html.
Then run "make TOOLPREFIX=i386-jos-elf-".

To run xv6, install the QEMU PC simulators.  To run in QEMU, run "make qemu".

To create a typeset version of the code, run "make xv6.pdf".  This
requires the "mpage" utility.  See http://www.mesa.nl/pub/mpage/.
