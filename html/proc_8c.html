<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CS 3210 Lab 3: proc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CS 3210 Lab 3
   </div>
   <div id="projectbrief">Scheduling and Kernel Threading</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">proc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main system calls defined here.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;types.h&quot;</code><br />
<code>#include &quot;defs.h&quot;</code><br />
<code>#include &quot;param.h&quot;</code><br />
<code>#include &quot;memlayout.h&quot;</code><br />
<code>#include &quot;mmu.h&quot;</code><br />
<code>#include &quot;x86.h&quot;</code><br />
<code>#include &quot;<a class="el" href="proc_8h_source.html">proc.h</a>&quot;</code><br />
<code>#include &quot;spinlock.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sched_8h_source.html">sched.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for proc.c:</div>
<div class="dyncontent">
<div class="center"><img src="proc_8c__incl.png" border="0" usemap="#proc_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11c5d62d28e8121e75235d361158156e"><td class="memItemLeft" align="right" valign="top"><a id="a11c5d62d28e8121e75235d361158156e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>forkret</b> (void)</td></tr>
<tr class="separator:a11c5d62d28e8121e75235d361158156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c085102b25a17b9a1a78db5a8be16f9"><td class="memItemLeft" align="right" valign="top"><a id="a6c085102b25a17b9a1a78db5a8be16f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trapret</b> (void)</td></tr>
<tr class="separator:a6c085102b25a17b9a1a78db5a8be16f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d293f913985937ee7a266fe5ddbfc77"><td class="memItemLeft" align="right" valign="top"><a id="a9d293f913985937ee7a266fe5ddbfc77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pinit</b> (void)</td></tr>
<tr class="separator:a9d293f913985937ee7a266fe5ddbfc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7bd1e43c250440fa7b0bd0182d699b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#a0c7bd1e43c250440fa7b0bd0182d699b">getcpu</a> (void)</td></tr>
<tr class="memdesc:a0c7bd1e43c250440fa7b0bd0182d699b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number ID of the cpu that is running the current process.  <a href="#a0c7bd1e43c250440fa7b0bd0182d699b">More...</a><br /></td></tr>
<tr class="separator:a0c7bd1e43c250440fa7b0bd0182d699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8a6a0cae413bc81aa223f7f7b7205"><td class="memItemLeft" align="right" valign="top"><a id="a81c8a6a0cae413bc81aa223f7f7b7205"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>userinit</b> (void)</td></tr>
<tr class="separator:a81c8a6a0cae413bc81aa223f7f7b7205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c16214741f4fcd088e5eea468709328"><td class="memItemLeft" align="right" valign="top"><a id="a9c16214741f4fcd088e5eea468709328"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>growproc</b> (int n)</td></tr>
<tr class="separator:a9c16214741f4fcd088e5eea468709328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2e1ded4bb6fce4500438bf928330f4"><td class="memItemLeft" align="right" valign="top"><a id="acd2e1ded4bb6fce4500438bf928330f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fork</b> (void)</td></tr>
<tr class="separator:acd2e1ded4bb6fce4500438bf928330f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa232f215207a1a92d49e3d08913367fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#aa232f215207a1a92d49e3d08913367fe">clone</a> (void *stack, void *func, void *arg)</td></tr>
<tr class="memdesc:aa232f215207a1a92d49e3d08913367fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new process, copying the calling process but sharing memory space.  <a href="#aa232f215207a1a92d49e3d08913367fe">More...</a><br /></td></tr>
<tr class="separator:aa232f215207a1a92d49e3d08913367fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49801e7d70b9be03aa7af5920a48d76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#aa49801e7d70b9be03aa7af5920a48d76">join</a> (void **stack)</td></tr>
<tr class="memdesc:aa49801e7d70b9be03aa7af5920a48d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a cloned process (thread) to finish execution. Join is like wait except it works with concurrent threads created from clone instead of forked processes created from fork. It will perform necessary checks to verify that there are still existing threads of the current process to wait for, and if it is not ready to freed upon calling, will go to sleep until the cloned process is done executing.  <a href="#aa49801e7d70b9be03aa7af5920a48d76">More...</a><br /></td></tr>
<tr class="separator:aa49801e7d70b9be03aa7af5920a48d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf98ef7cdde3a0dfb2e49919de3298b1"><td class="memItemLeft" align="right" valign="top"><a id="aaf98ef7cdde3a0dfb2e49919de3298b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exit</b> (void)</td></tr>
<tr class="separator:aaf98ef7cdde3a0dfb2e49919de3298b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f31822f7e737b4e414bdac1ccb59a4"><td class="memItemLeft" align="right" valign="top"><a id="af6f31822f7e737b4e414bdac1ccb59a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (void)</td></tr>
<tr class="separator:af6f31822f7e737b4e414bdac1ccb59a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a64d47783aef137a6ab3eab48157e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#ad3a64d47783aef137a6ab3eab48157e5">setscheduler</a> (int policy, int priority)</td></tr>
<tr class="memdesc:ad3a64d47783aef137a6ab3eab48157e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scheduling policy and priority of the current process. Will immediately preempt back to the scheduler if the process is being set to a FIFO scheduler.  <a href="#ad3a64d47783aef137a6ab3eab48157e5">More...</a><br /></td></tr>
<tr class="separator:ad3a64d47783aef137a6ab3eab48157e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac600ab7372d6803b60514b2ee4b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#abbac600ab7372d6803b60514b2ee4b79">run_proc</a> (struct <a class="el" href="structproc.html">proc</a> *p)</td></tr>
<tr class="memdesc:abbac600ab7372d6803b60514b2ee4b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracted process switching done by the scheduler to switch contexts to the next process to run.  <a href="#abbac600ab7372d6803b60514b2ee4b79">More...</a><br /></td></tr>
<tr class="separator:abbac600ab7372d6803b60514b2ee4b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa00b0be5d3c4781048861e2506eb63"><td class="memItemLeft" align="right" valign="top"><a id="a9fa00b0be5d3c4781048861e2506eb63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="proc_8c.html#a9fa00b0be5d3c4781048861e2506eb63">scheduler</a> (void)</td></tr>
<tr class="memdesc:a9fa00b0be5d3c4781048861e2506eb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function that each CPU will run to switch between processes. Will never return.<br />
This is where each CPU will spend time searching for the next process to run and where to core of the scheduling algorithms is taken care of. It will first look over the process table and run the FIFO process with the highest priority. If there are no FIFO processes, it will then look over the table again, searching for the highest priority Round Robin process. If it finds a FIFO process while searching for Round Robin processes, it will break and begin again since a process with a higher priority has been added in the time it has been looking through the table. <br /></td></tr>
<tr class="separator:a9fa00b0be5d3c4781048861e2506eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad788da91743c333b5bed7c4a0dd12365"><td class="memItemLeft" align="right" valign="top"><a id="ad788da91743c333b5bed7c4a0dd12365"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sched</b> (void)</td></tr>
<tr class="separator:ad788da91743c333b5bed7c4a0dd12365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb51f5c2b5cad3766f19eb69c92793b"><td class="memItemLeft" align="right" valign="top"><a id="a7cb51f5c2b5cad3766f19eb69c92793b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>yield</b> (void)</td></tr>
<tr class="separator:a7cb51f5c2b5cad3766f19eb69c92793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70cc0370342e46f6db3bec367232457"><td class="memItemLeft" align="right" valign="top"><a id="ae70cc0370342e46f6db3bec367232457"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sleep</b> (void *chan, struct <a class="el" href="structspinlock.html">spinlock</a> *lk)</td></tr>
<tr class="separator:ae70cc0370342e46f6db3bec367232457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34d9f03e436cfa09b88f735f6ee952"><td class="memItemLeft" align="right" valign="top"><a id="a4a34d9f03e436cfa09b88f735f6ee952"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wakeup</b> (void *chan)</td></tr>
<tr class="separator:a4a34d9f03e436cfa09b88f735f6ee952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650cf0caaaa8b75f653c1c92818d03a4"><td class="memItemLeft" align="right" valign="top"><a id="a650cf0caaaa8b75f653c1c92818d03a4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kill</b> (int pid)</td></tr>
<tr class="separator:a650cf0caaaa8b75f653c1c92818d03a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f185044294ebb57521c73f723990164"><td class="memItemLeft" align="right" valign="top"><a id="a7f185044294ebb57521c73f723990164"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>procdump</b> (void)</td></tr>
<tr class="separator:a7f185044294ebb57521c73f723990164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab70c9b51ec4950b253dd41ea643d7763"><td class="memItemLeft" ><a id="ab70c9b51ec4950b253dd41ea643d7763"></a>
struct {</td></tr>
<tr class="memitem:a489696401a3ecf326b8b64422898705f"><td class="memItemLeft" >
&#160;&#160;&#160;struct <a class="el" href="structspinlock.html">spinlock</a>&#160;&#160;&#160;<b>lock</b></td></tr>
<tr class="separator:a489696401a3ecf326b8b64422898705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d98f1125ebc6db055c6a0c7bd8352c"><td class="memItemLeft" >
&#160;&#160;&#160;struct <a class="el" href="structproc.html">proc</a>&#160;&#160;&#160;<b>proc</b> [NPROC]</td></tr>
<tr class="separator:a67d98f1125ebc6db055c6a0c7bd8352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70c9b51ec4950b253dd41ea643d7763"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><b>ptable</b></td></tr>
<tr class="separator:ab70c9b51ec4950b253dd41ea643d7763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec016216766697de7529c7b9cb5beda9"><td class="memItemLeft" align="right" valign="top"><a id="aec016216766697de7529c7b9cb5beda9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nextpid</b> = 1</td></tr>
<tr class="separator:aec016216766697de7529c7b9cb5beda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main system calls defined here. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa232f215207a1a92d49e3d08913367fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa232f215207a1a92d49e3d08913367fe">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int clone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new process, copying the calling process but sharing memory space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Pointer to the new user stack, already allocated by the caller. </td></tr>
    <tr><td class="paramname">func</td><td>Pointer to where to continue execution after return to calling process. </td></tr>
    <tr><td class="paramname">arg</td><td>Arguments necessary for 'func' on return to calling process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In the calling process, returns the pid. In the created cloned process, will return 0. </dd></dl>

</div>
</div>
<a id="a0c7bd1e43c250440fa7b0bd0182d699b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7bd1e43c250440fa7b0bd0182d699b">&#9670;&nbsp;</a></span>getcpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getcpu </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number ID of the cpu that is running the current process. </p>
<dl class="section return"><dt>Returns</dt><dd>ID of the current process' CPU. </dd></dl>

</div>
</div>
<a id="aa49801e7d70b9be03aa7af5920a48d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49801e7d70b9be03aa7af5920a48d76">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a cloned process (thread) to finish execution. Join is like wait except it works with concurrent threads created from clone instead of forked processes created from fork. It will perform necessary checks to verify that there are still existing threads of the current process to wait for, and if it is not ready to freed upon calling, will go to sleep until the cloned process is done executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Space to store the cloned process' user stack so that it can be freed once back in userspace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successful joining of an exiting thread, will return that thread's pid. Otherwise, will return -1 if the currently running process has no threads or if it has been killed. </dd></dl>

</div>
</div>
<a id="abbac600ab7372d6803b60514b2ee4b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac600ab7372d6803b60514b2ee4b79">&#9670;&nbsp;</a></span>run_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void run_proc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structproc.html">proc</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abstracted process switching done by the scheduler to switch contexts to the next process to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The selected process to swtch() to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a64d47783aef137a6ab3eab48157e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a64d47783aef137a6ab3eab48157e5">&#9670;&nbsp;</a></span>setscheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setscheduler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scheduling policy and priority of the current process. Will immediately preempt back to the scheduler if the process is being set to a FIFO scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The selected scheduling policy to apply to the process. Defined in <a class="el" href="sched_8h.html" title="Definitions for new scheduling policies.">sched.h</a> in the schedpolicy_lab3 enum. </td></tr>
    <tr><td class="paramname">priority</td><td>An integer priority to set for the process. Higher priority means it will be executed before lower priority processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on successful execution. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
